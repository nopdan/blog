[{"categories":["项目"],"content":" 项目地址: https://github.com/nopdan/gosmq/ “赛码器”是一种用于评估不同输入法方案(主要是码表类方案)之间“性能”差异的工具。 ","date":"2025-02-18","objectID":"/2025/02/gosmq/:0:0","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#"},{"categories":["项目"],"content":" 如何评估码表类输入法方案","date":"2025-02-18","objectID":"/2025/02/gosmq/:1:0","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#如何评估码表类输入法方案"},{"categories":["项目"],"content":" 静态分析根据静态码表进行分析，一般会区分单字和词组。常见工具如下: 形码评测系统 by 法月(Excel)、yb6b(Python) 组词测评系统 by 法月(Excel)、yb6b(Python) 测评网站 by 虎码作者 网页上传码表，单字评测和组词评测 ","date":"2025-02-18","objectID":"/2025/02/gosmq/:1:1","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#静态分析"},{"categories":["项目"],"content":" 动态分析分析码表在特定某一篇或多篇文章的表现。常见工具如下: 自由输入法编码工具箱 by 獨来 du 往 极速赛码器 by 消逝 最经典也是最常用的评测工具，界面美观。 需要转换码表格式且只支持 UTF-16LE 编码格式，性能较低。 昙花赛码器 by nopdan Golang 编写，性能最优，同时支持命令行和 server 端，支持多种码表格式，自动识别编码格式。 形码盒子 by yb6b 网页上传，即点即用，性能较优，支持多种码表格式。 ","date":"2025-02-18","objectID":"/2025/02/gosmq/:1:2","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#动态分析"},{"categories":["项目"],"content":" 为什么要写昙花赛码器主要是针对「极速赛码器」的改进。 性能，这是最主要的原因。「极速赛码器」对系统资源利用极低，内存只用到 10+MB，CPU 占用百分之几，性能低下，10w 字文章要几十秒，上百万文章基本不可用。 易用性，「极速赛码器」需要手动转换码表格式，且对编码格式有限制。 学习 Golang，这是我用 Golang 写的第一个项目。 ","date":"2025-02-18","objectID":"/2025/02/gosmq/:2:0","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#为什么要写昙花赛码器"},{"categories":["项目"],"content":" 赛码器架构设计与性能优化昙花赛码器（Gosmq）从设计之初就注重性能，并且在开发过程中不断进行优化。其核心目标是实现对多个码表和多篇文章（m:n）的同时赛码。 ","date":"2025-02-18","objectID":"/2025/02/gosmq/:3:0","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#赛码器架构设计与性能优化"},{"categories":["项目"],"content":" 码表处理为了提升码表的构建和加载速度，昙花赛码器采用了自定义的赛码表格式。这种格式针对赛码场景进行了专门优化，能够快速加载和解析码表，减少初始化时间。 当然，其他格式如极点、rime 等同样支持，在第一次使用其他格式的码表会自动转换为专用的赛码表格式，下次使用就能得到加速。 ","date":"2025-02-18","objectID":"/2025/02/gosmq/:3:1","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#码表处理"},{"categories":["项目"],"content":" 文章处理通过流式读取和文本分段技术，结合 Golang 的协程（goroutine）能力，充分利用了多核 CPU 的性能。 流式读取：采用流式读取方式处理文章，根据文件大小智能分配缓冲区尺寸，避免一次性加载大文件导致的内存占用过高问题。 文本分段：将文章分段处理，结合协程并发执行，充分利用多核 CPU 的计算能力。 文本分段算法: go func (t *Text) Iter() ([]byte, error) { if t.reader == nil { return nil, io.EOF } if t.size \u003c t.bufSize { return io.ReadAll(t.reader) } buffer := make([]byte, t.bufSize, t.bufSize+4*1024) n, _ := io.ReadFull(t.reader, buffer) buffer = buffer[:n] for { b, err := t.reader.ReadByte() // EOF if err != nil { return buffer, io.EOF } // 防止切到 utf-8 编码中间 if b \u003c 33 { // 控制字符 直接切分 return buffer, nil } else if b \u003c 0b11000000 { // 0b0xxxxxxx || 0b10xxxxxx // ascii 码，或者 utf-8 编码后几位 buffer = append(buffer, b) continue } else { // 0b11xxxxxx // utf-8 前缀，回退，之后读取 rune _ = t.reader.UnreadByte() break } } for { r, _, _ := t.reader.ReadRune() // 控制字符 直接切分 if r \u003c 33 { return buffer, nil } switch r { case '“', '‘', '：', '《': _ = t.reader.UnreadRune() return buffer, nil } b := util.UnsafeToBytes(string(r)) // 超过 buffer 容量直接返回，减少切片扩容 if len(buffer)+len(b) \u003e cap(buffer) { _ = t.reader.UnreadRune() return buffer, nil } buffer = append(buffer, b...) switch r { case '。', '？', '！', '》': return buffer, nil } } } ","date":"2025-02-18","objectID":"/2025/02/gosmq/:3:2","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#文章处理"},{"categories":["项目"],"content":" 字符串匹配算法使用基于哈希的字典树(trie)，兼具构建速度、匹配速度和内存占用。 ","date":"2025-02-18","objectID":"/2025/02/gosmq/:3:3","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#字符串匹配算法"},{"categories":["项目"],"content":" 用户交互与数据展示 命令行使用 go-pretty 包美化输出结果。 web使用 bunjs + vue + naive-ui，配合 go1.16 新特性 go embed ","date":"2025-02-18","objectID":"/2025/02/gosmq/:3:4","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#用户交互与数据展示"},{"categories":["项目"],"content":" 用户交互与数据展示 命令行使用 go-pretty 包美化输出结果。 web使用 bunjs + vue + naive-ui，配合 go1.16 新特性 go embed ","date":"2025-02-18","objectID":"/2025/02/gosmq/:3:4","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#命令行"},{"categories":["项目"],"content":" 用户交互与数据展示 命令行使用 go-pretty 包美化输出结果。 web使用 bunjs + vue + naive-ui，配合 go1.16 新特性 go embed ","date":"2025-02-18","objectID":"/2025/02/gosmq/:3:4","series":null,"tags":["go","输入法"],"title":"输入法评测工具——昙花赛码器","uri":"/2025/02/gosmq/#web"},{"categories":["输入法"],"content":"微软拼音和微软五笔通用的用户自定义短语 dat 格式。 ","date":"2022-09-17","objectID":"/2022/09/07-msudp-dat/:0:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（七）微软用户自定义短语.dat","uri":"/2022/09/07-msudp-dat/#"},{"categories":["输入法"],"content":" 解析 前 8 个字节标识文件格式 machxudp，微软五笔的 lex 格式是 imscwubi。 下面 8 个字节应该是版本号。 接下来每 4 字节一组，分别表示偏移表开始、词条开始、文件总长、词条数、导出的时间戳。 然后补 0 一直到偏移表开始。 偏移表记录了每个词条从词条开始的偏移量，每 4 个字节一组。 接下来就是词条本体部分： # 占用字节数 描述 4 10 00 10 00 标记 a 2 该词条总字节长 - 词占用的字节长 1 在候选中的位置 1 0x06或0x13，未知 4 0 4 从2010-01-01开始的时间戳 a - 16 编码（utf-16le），00 标识结束 词条总字节长 - a 词（utf-16le），00 标识结束 代码实现： go func (MsUDP) Parse(filename string) Table { data, _ := os.ReadFile(filename) r := bytes.NewReader(data) ret := make(Table, 0, r.Len()\u003e\u003e8) // 词库偏移量 r.Seek(0x10, 0) offset_start := ReadUint32(r) // 偏移表开始 entry_start := ReadUint32(r) // 词条开始 entry_end := ReadUint32(r) // 词条结束 entry_count := ReadUint32(r) // 词条数 export_time := ReadUint32(r) // 导出的时间 t := time.Unix(int64(export_time), 0) fmt.Println(t, entry_end) // 第一个偏移量 offset := 0 for i := 0; i \u003c entry_count; i++ { var next, length int if i == entry_count-1 { length = entry_end - entry_start - offset } else { r.Seek(int64(offset_start+4*(i+1)), 0) next = ReadUint32(r) length = next - offset } // fmt.Println(offset, next, length) r.Seek(int64(offset+entry_start), 0) offset = next ReadUint32(r) // 0x10001000 codeLen := ReadUint16(r) // 编码字节长+0x12 order, _ := r.ReadByte() // 顺序 _, _ = r.ReadByte() // 0x06 不明 ReadUint32(r) // 4 个空字节 ReadUint32(r) // 时间戳 tmp := make([]byte, codeLen-0x12) r.Read(tmp) code, _ := util.Decode(tmp, \"UTF-16LE\") ReadUint16(r) // 两个空字节 tmp = make([]byte, length-codeLen-2) r.Read(tmp) word, _ := util.Decode(tmp, \"UTF-16LE\") fmt.Println(code, word) ret = append(ret, Entry{word, code, order}) } return ret } ","date":"2022-09-17","objectID":"/2022/09/07-msudp-dat/:1:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（七）微软用户自定义短语.dat","uri":"/2022/09/07-msudp-dat/#解析"},{"categories":["输入法"],"content":" 生成只需注意文件总长先用空字节代替，最后才写入。 代码实现： go func (MsUDP) Gen(table Table) []byte { var buf bytes.Buffer stamp := util.GetUint32(int(time.Now().Unix())) buf.Write([]byte{0x6D, 0x73, 0x63, 0x68, 0x78, 0x75, 0x64, 0x70, 0x02, 0x00, 0x60, 0x00, 0x01, 0x00, 0x00, 0x00}) buf.Write(util.GetUint32(0x40)) buf.Write(util.GetUint32(0x40 + 4*len(table))) buf.Write(make([]byte, 4)) // 待定 文件总长 buf.Write(util.GetUint32(len(table))) buf.Write(stamp) buf.Write(make([]byte, 28)) buf.Write(make([]byte, 4)) words := make([][]byte, 0, len(table)) codes := make([][]byte, 0, len(table)) sum := 0 for i := range table { word, _ := util.Encode([]byte(table[i].Word), \"UTF-16LE\") code, _ := util.Encode([]byte(table[i].Code), \"UTF-16LE\") words = append(words, word) codes = append(codes, code) if i != len(table)-1 { sum += len(word) + len(code) + 20 buf.Write(util.GetUint32(sum)) } } for i := range table { buf.Write([]byte{0x10, 0x00, 0x10, 0x00}) // fmt.Println(words[i], len(words[i]), codes[i], len(codes[i])) buf.Write(util.GetUint16(len(codes[i]) + 18)) buf.WriteByte(table[i].Order) buf.WriteByte(0x06) buf.Write(make([]byte, 4)) buf.Write(stamp) buf.Write(codes[i]) buf.Write([]byte{0, 0}) buf.Write(words[i]) buf.Write([]byte{0, 0}) } b := buf.Bytes() copy(b[0x18:0x1c], util.GetUint32(len(b))) return b } ","date":"2022-09-17","objectID":"/2022/09/07-msudp-dat/:2:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（七）微软用户自定义短语.dat","uri":"/2022/09/07-msudp-dat/#生成"},{"categories":["输入法"],"content":".qpyd 是 QQ 拼音输入法 6.0 以下版本所用的词库格式，可以在 http://cdict.qq.pinyin.cn/v1/ 下载。 该格式解析的主要难点是其使用了 zlib 压缩，解压后的数据很好解析。 ","date":"2022-05-25","objectID":"/2022/05/06-qq-qpyd/:0:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（六）QQ 拼音分类词库.qpyd","uri":"/2022/05/06-qq-qpyd/#"},{"categories":["输入法"],"content":" 解析","date":"2022-05-25","objectID":"/2022/05/06-qq-qpyd/:1:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（六）QQ 拼音分类词库.qpyd","uri":"/2022/05/06-qq-qpyd/#解析"},{"categories":["输入法"],"content":" 原始文件 0x38 后跟的 4 字节表示压缩数据开始的字节。 0x44 后跟的 4 字节表示词条数。 0x60 - 0x16F 是词库的一些描述信息。 其余未知。 ","date":"2022-05-25","objectID":"/2022/05/06-qq-qpyd/:1:1","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（六）QQ 拼音分类词库.qpyd","uri":"/2022/05/06-qq-qpyd/#原始文件"},{"categories":["输入法"],"content":" 解压数据使用了 zlib 格式。 我们看看解压后的数据是什么形式。 可以发现它分为两部分，前部分每 10 个一组，总长 10*词条数。 放到文本编辑器里分析一下，这里取了前后两部分前三条。 可以看到前部分是编码长和词长信息，后半部分 ascii 的编码 + utf-16le 的词条。 前半部分保存了所有词条的编码长，词长，索引位置。 占用字节数 描述 1 拼音的长度 1 词字节长 4 未知，全是00 00 80 3F 4 词条的索引位置 后半部分就是词条本身了，拼音和词，词条之间都是紧挨着的。 前面是编码，框里的是词。 代码实现： go func (QqQpyd) Parse(filename string) Dict { data, _ := os.ReadFile(filename) r := bytes.NewReader(data) ret := make(Dict, 0, r.Len()\u003e\u003e8) var tmp []byte // 0x38 后跟的是压缩数据开始的偏移量 r.Seek(0x38, 0) startZip := ReadUint32(r) // 0x44 后4字节是词条数 r.Seek(0x44, 0) dictLen := ReadUint32(r) // 0x60 到zip数据前的一段是一些描述信息 r.Seek(0x60, 0) head := make([]byte, startZip-0x60) r.Read(head) // headStr, _ := Decode(head, \"UTF-16LE\") // fmt.Println(headStr) // 打印描述信息 // 解压数据 zrd, err := zlib.NewReader(r) if err != nil { log.Panic(err) } defer zrd.Close() buf := new(bytes.Buffer) buf.Grow(r.Len()) _, err = io.Copy(buf, zrd) if err != nil { log.Panic(err) } // 解压完了 r.Reset(buf.Bytes()) for i := 0; i \u003c dictLen; i++ { // 指向当前 r.Seek(int64(10*i), 0) // 读码长、词长、索引 addr := make([]byte, 10) r.Read(addr) idx := BytesToInt(addr[6:]) // 后4字节是索引 r.Seek(int64(idx), 0) // 指向索引 // 读编码，自带 ' 分隔符 tmp = make([]byte, addr[0]) r.Read(tmp) code := string(tmp) // 读词 tmp = make([]byte, addr[1]) r.Read(tmp) word, _ := util.Decode(tmp, \"UTF-16LE\") ret = append(ret, Entry{word, strings.Split(code, \"'\"), 1}) } return ret } ","date":"2022-05-25","objectID":"/2022/05/06-qq-qpyd/:1:2","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（六）QQ 拼音分类词库.qpyd","uri":"/2022/05/06-qq-qpyd/#解压数据"},{"categories":["输入法"],"content":"mb 是极点五笔的码表格式。 ","date":"2022-05-24","objectID":"/2022/05/05-jidian-mb/:0:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（五）极点码表.mb","uri":"/2022/05/05-jidian-mb/#"},{"categories":["输入法"],"content":" 解析 偏移量 描述 0x00 版本信息 0x1B 码表介绍 0x11F 所用到的按键数 0x120 所用到的按键，utf-16le 0x154 万能键 0x156 编码截止键 0x176 组词规则 0x176 组词规则 0x194 径直上屏的标点 0x1B4 特殊符号引导符 0x1B8 未知 0x1B620 左右 码表 上图选中部分解析为 text 五笔点儿词库2022春 QQ群313225526 生成日期:2022-3-17 18:36 所有用到的按键： 组词规则： 特殊符号引导符： 下面的部分就有规律了 每 4 个字节一组，前两个字节表示一个字符，后两个字节从 00 00 ~ 29 00，一共 41 个值（意义不明，可能是某种索引），中间有一些 FF FF FF FF 一直到 0x1B620左右，有的词库可能会相差几个字节。 下面才是词库部分。 占用字节数 描述 a 1 编码长度 b 1 词字节长度 1 只有 0x64、0x32、0x10 几个值，意义不明 a 编码，ascii b 词，utf-16le 代码实现（只读 0x1B620 之后的码表）： go func (JidianMb) Parse(filename string) Table { data, _ := os.ReadFile(filename) r := bytes.NewReader(data) ret := make(Table, 0, r.Len()\u003e\u003e8) var tmp []byte r.Seek(0x1B620, 0) // 从 0x1B620 开始读 for r.Len() \u003e 3 { codeLen, _ := r.ReadByte() if codeLen == 0xff { r.Seek(1, 1) continue } wordLen, _ := r.ReadByte() r.Seek(1, 1) // 读编码 tmp = make([]byte, codeLen) r.Read(tmp) code := string(tmp) // 读词 tmp = make([]byte, wordLen) r.Read(tmp) word, _ := util.Decode(tmp, \"UTF-16LE\") ret = append(ret, Entry{word, code, 1}) } return ret } ","date":"2022-05-24","objectID":"/2022/05/05-jidian-mb/:1:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（五）极点码表.mb","uri":"/2022/05/05-jidian-mb/#解析"},{"categories":["输入法"],"content":".bdict 是百度的分类词库格式，可以在 https://shurufa.baidu.com/dict 下载。 手机百度的分类词库格式 .bcd 是一样的，可以在 https://mime.baidu.com/web/iw/index/ 下载。 ","date":"2022-05-24","objectID":"/2022/05/04-baidu-bdict/:0:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（四）百度分类词库.bdict(.bcd)","uri":"/2022/05/04-baidu-bdict/#"},{"categories":["输入法"],"content":" 解析 范围 描述 0x70 - 0x73 词条数 0x90 - 0xCF 词库名 0xD0 - 0x10F 词库作者 0x110 - 0x14F 示例词 0x150 - 0x34F 词库描述 有的词库在 0x250 开始的后 4 个字节是大端序的词条数。 码表偏移 0x350 词库不带拼音表，需要根据词库规纳出来，参考深蓝词库转换。 内部根据是否含有英文分为几种格式 ","date":"2022-05-24","objectID":"/2022/05/04-baidu-bdict/:1:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（四）百度分类词库.bdict(.bcd)","uri":"/2022/05/04-baidu-bdict/#解析"},{"categories":["输入法"],"content":" 格式一纯中文 # 占用字节数 描述 a 2 拼音长，词长 2 词频 a*2 拼音，（声母索引\u003c24+韵母索引\u003c33） a*2 词，utf-16le 编码 带英文的，结构差不多，声母索引为 0xFF 表示英文字母 ","date":"2022-05-24","objectID":"/2022/05/04-baidu-bdict/:1:1","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（四）百度分类词库.bdict(.bcd)","uri":"/2022/05/04-baidu-bdict/#格式一"},{"categories":["输入法"],"content":" 格式二：纯英文编码使用 ascii # 占用字节数 描述 a 2 词长 2 词频 a 词，ascii 编码 ","date":"2022-05-24","objectID":"/2022/05/04-baidu-bdict/:1:2","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（四）百度分类词库.bdict(.bcd)","uri":"/2022/05/04-baidu-bdict/#格式二纯英文"},{"categories":["输入法"],"content":" 格式三：编码和词不等长拼音不再使用索引，而是直接使用 utf-16le 编码 # 占用字节数 描述 a 2 编码数 2 词频 2 空 b 2 词长 a*2 编码，utf-16le b*2 词，utf-16le 代码实现： go var bdictSm = []string{ \"c\", \"d\", \"b\", \"f\", \"g\", \"h\", \"ch\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\", \"p\", \"q\", \"r\", \"s\", \"t\", \"sh\", \"zh\", \"w\", \"x\", \"y\", \"z\", } var bdictYm = []string{ \"uang\", \"iang\", \"iong\", \"ang\", \"eng\", \"ian\", \"iao\", \"ing\", \"ong\", \"uai\", \"uan\", \"ai\", \"an\", \"ao\", \"ei\", \"en\", \"er\", \"ua\", \"ie\", \"in\", \"iu\", \"ou\", \"ia\", \"ue\", \"ui\", \"un\", \"uo\", \"a\", \"e\", \"i\", \"o\", \"u\", \"v\", } func (BaiduBdict) Parse(filename string) Dict { data, _ := os.ReadFile(filename) r := bytes.NewReader(data) ret := make(Dict, 0, r.Len()\u003e\u003e8) var tmp []byte r.Seek(0x350, 0) for r.Len() \u003e 4 { // 拼音长 pyLen := ReadUint16(r) // 词频 freq := ReadUint16(r) // 判断下两个字节 tmp = make([]byte, 2) r.Read(tmp) // 编码和词不等长，全按 utf-16le if tmp[0] == 0 \u0026\u0026 tmp[1] == 0 { wordLen := ReadUint16(r) // 读编码 tmp = make([]byte, pyLen*2) r.Read(tmp) code, _ := util.Decode(tmp, \"UTF-16LE\") // 读词 tmp = make([]byte, wordLen*2) r.Read(tmp) word, _ := util.Decode(tmp, \"UTF-16LE\") ret = append(ret, Entry{ Word: word, Pinyin: []string{code}, Freq: freq, }) continue } // 全英文的词，编码和词是一样的 if int(tmp[0]) \u003e= len(bdictSm) \u0026\u0026 tmp[0] != 0xff { r.Seek(-2, 1) eng := make([]byte, pyLen) r.Read(eng) ret = append(ret, Entry{ Word: string(eng), Pinyin: []string{string(eng)}, Freq: freq, }) continue } // 一般格式 r.Seek(-2, 1) pinyin := make([]string, 0, pyLen) for i := 0; i \u003c pyLen; i++ { smIdx, _ := r.ReadByte() ymIdx, _ := r.ReadByte() // 带英文的词组 if smIdx == 0xff { pinyin = append(pinyin, string(ymIdx)) continue } pinyin = append(pinyin, bdictSm[smIdx]+bdictYm[ymIdx]) } // 读词 tmp = make([]byte, pyLen*2) r.Read(tmp) word, _ := util.Decode(tmp, \"UTF-16LE\") ret = append(ret, Entry{ Word: word, Pinyin: pinyin, Freq: freq, }) } return ret } 参考资料： 深蓝词库转换 ","date":"2022-05-24","objectID":"/2022/05/04-baidu-bdict/:1:3","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（四）百度分类词库.bdict(.bcd)","uri":"/2022/05/04-baidu-bdict/#格式三编码和词不等长"},{"categories":["输入法"],"content":".uwl 是紫光拼音输入法（现在叫华宇拼音输入法）使用的词库。 ","date":"2022-05-24","objectID":"/2022/05/03-ziguang-uwl/:0:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（三）紫光拼音词库.uwl","uri":"/2022/05/03-ziguang-uwl/#"},{"categories":["输入法"],"content":" 解析紫光的词库有点复杂，拼音用的索引，但是拼音表没有写在词库里。 好在深蓝词库转换工具已经解析好了，这部分就跳过了。 词长和拼音长关系密切，要注意。 主要词库部分每 1024 字节为一段（分段意义何在？） 前两个字节未知，第 3 个字节表示字符编码格式 0x08 是 GBK，0x09 是 UTF-16LE。 范围 描述 0x04 - 0x23 词库名 0x24 - 0x43 词库作者 0x44 - 0x47 词条数 0x48 - 0x4B 分为几段 0x4C - 0xBFF 未知。 从 0xC00 开始，每 1024 为一段，一段有个 16 字节的头信息。 4 个字节为一组，分别表示：第几段，未知，未知，词条占用字节数(小于 1024-16)。 占用字节数 描述 a 1 词占用字节 + 1（所以总是奇数），可能大于 0x80 b 1 拼音长度的一半，前 4 位（总是偶数）意义不明 2 词频 b%0x10*2 + a/0x80 拼音索引 a%0x80 - 1 词 代码实现： go var uwlSm = []string{ \"\", \"b\", \"c\", \"ch\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\", \"m\", \"n\", \"p\", \"q\", \"r\", \"s\", \"sh\", \"t\", \"w\", \"x\", \"y\", \"z\", \"zh\", } var uwlYm = []string{ \"ang\", \"a\", \"ai\", \"an\", \"ang\", \"ao\", \"e\", \"ei\", \"en\", \"eng\", \"er\", \"i\", \"ia\", \"ian\", \"iang\", \"iao\", \"ie\", \"in\", \"ing\", \"iong\", \"iu\", \"o\", \"ong\", \"ou\", \"u\", \"ua\", \"uai\", \"uan\", \"uang\", \"ue\", \"ui\", \"un\", \"uo\", \"v\", } func (ZiguangUwl) Parse(filename string) Dict { data, _ := os.ReadFile(filename) r := bytes.NewReader(data) ret := make(Dict, 0, r.Len()\u003e\u003e8) r.Seek(2, 0) // 编码格式，08 为 GBK，09 为 UTF-16LE encoding, _ := r.ReadByte() // 分段 r.Seek(0x48, 0) partLen := ReadUint32(r) for i := 0; i \u003c partLen; i++ { r.Seek(0xC00+int64(i)\u003c\u003c10, 0) ret = parseZgUwlPart(r, ret, encoding) } return ret } func parseZgUwlPart(r *bytes.Reader, ret Dict, e byte) Dict { r.Seek(12, 1) // 词条占用字节数 max := ReadUint32(r) // 当前字节 curr := 0 for curr \u003c max { head := make([]byte, 4) r.Read(head) // 词长 * 2 wordLen := head[0]%0x80 - 1 // 拼音长 codeLen := head[1]\u003c\u003c4\u003e\u003e4*2 + head[0]/0x80 // 频率 freq := BytesToInt(head[2:]) // fmt.Println(freqSli, freq) curr += int(4 + wordLen + codeLen*2) // 拼音 code := make([]string, 0, codeLen) for i := 0; i \u003c int(codeLen); i++ { bsm, _ := r.ReadByte() bym, _ := r.ReadByte() smIdx := bsm \u0026 0x1F ymIdx := (bsm \u003e\u003e 5) + (bym \u003c\u003c 3) // fmt.Println(bsm, bym, smIdx, ymIdx) if bym \u003e= 0x10 || smIdx \u003e= 24 || ymIdx \u003e= 34 { break } code = append(code, uwlSm[smIdx]+uwlYm[ymIdx]) // fmt.Println(smIdx, ymIdx, uwlSm[smIdx]+uwlYm[ymIdx]) } // 词 tmp := make([]byte, wordLen) r.Read(tmp) var word string switch e { case 0x08: word, _ = util.Decode(tmp, \"GBK\") case 0x09: word, _ = util.Decode(tmp, \"UTF-16LE\") } // fmt.Println(string(word)) ret = append(ret, Entry{word, code, freq}) } return ret } 参考资料： 深蓝词库转换 ","date":"2022-05-24","objectID":"/2022/05/03-ziguang-uwl/:1:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（三）紫光拼音词库.uwl","uri":"/2022/05/03-ziguang-uwl/#解析"},{"categories":["输入法"],"content":".scel 是搜狗拼音输入法所使用的细胞词库格式，可以在 https://pinyin.sogou.com/dict/ 下载。 .qcel 是 QQ 拼音输入法 6.0 以上版本所用的词库格式，可以在 http://cdict.qq.pinyin.cn/ 下载。 ","date":"2022-05-24","objectID":"/2022/05/02-sogou-scel/:0:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（二）搜狗拼音细胞词库.scel(.qcel)","uri":"/2022/05/02-sogou-scel/#"},{"categories":["输入法"],"content":" 解析 # 范围 描述 0x00 - 0x11F 未知 a 0x120 - 0x123 不展开重码的词条数（编码数） b 0x124 - 0x127 展开重码的词条数（词数） 0x128 - 0x12B 未知，和 a 有关 0x12C - 0x12F 未知，和 b 有关 0x130 - 0x337 词库名 0x338 - 0x53F 地点？ 0x540 - 0xD3F 备注 0xD40 - 0x153F 示例词 ","date":"2022-05-24","objectID":"/2022/05/02-sogou-scel/:1:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（二）搜狗拼音细胞词库.scel(.qcel)","uri":"/2022/05/02-sogou-scel/#解析"},{"categories":["输入法"],"content":" 拼音表从 0x1540 开始。 前两个字节是拼音表的长度。这里 9D 01 就表示有 0x100 * 0x01 + 0x9D = 413 组。 后两个字节意义不明，一般是 0。 从 0x1544 开始就是拼音表正文部分。 # 占用字节数 描述 2 索引，从 00 00 到 9C 01 a 2 拼音字节的长度 a 拼音，utf-16le 编码，一个字母占 2 字节。 带英文词库的索引： 从拼音表的长度往后，依次是 abcd。比如表长 413，最大索引9D 01，则下一个索引9E 01表示字母 a，依次类推。 ","date":"2022-05-24","objectID":"/2022/05/02-sogou-scel/:1:1","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（二）搜狗拼音细胞词库.scel(.qcel)","uri":"/2022/05/02-sogou-scel/#拼音表"},{"categories":["输入法"],"content":" 词库偏移量 0x2628 # 占用字节数 描述 2 同一个音有多少词 a 2 拼音索引的字节长度 a 拼音索引数组 b 2 词占用字节数 b 词，utf-16le 编码 c 2 描述信息字节长度 c 描述 ","date":"2022-05-24","objectID":"/2022/05/02-sogou-scel/:1:2","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（二）搜狗拼音细胞词库.scel(.qcel)","uri":"/2022/05/02-sogou-scel/#词库"},{"categories":["输入法"],"content":" 黑名单一些新的 .scel 文件最后有一个黑名单词库。 前 12 个字节表示标识 DELTBL。 接下来 2 个字节表示黑名单词库词条数。 # 占用字节数 描述 a 2 词长 a*2 词 代码实现： go func (SogouScel) Parse(filename string) Dict { data, _ := os.ReadFile(filename) r := bytes.NewReader(data) ret := make(Dict, 0, r.Len()\u003e\u003e8) var tmp []byte // 不展开的词条数 r.Seek(0x120, 0) dictLen := ReadUint32(r) // 拼音表偏移量 r.Seek(0x1540, 0) // 前两个字节是拼音表长度，413 pyTableLen := ReadUint16(r) pyTable := make([]string, pyTableLen) // fmt.Println(\"拼音表长度\", pyTableLen) // 丢掉两个字节 r.Seek(2, 1) // 读拼音表 for i := 0; i \u003c pyTableLen; i++ { // 索引，2字节 idx := ReadUint16(r) // 拼音长度，2字节 pyLen := ReadUint16(r) // 拼音 utf-16le tmp = make([]byte, pyLen) r.Read(tmp) py, _ := util.Decode(tmp, \"UTF-16LE\") // pyTable[idx] = string(py) } // 读码表 for j := 0; j \u003c dictLen; j++ { // 重码数（同一串音对应多个词） repeat := ReadUint16(r) // 索引数组长 pinyinSize := ReadUint16(r) // 读取编码 var pinyin []string for i := 0; i \u003c pinyinSize/2; i++ { theIdx := ReadUint16(r) if theIdx \u003e= pyTableLen { pinyin = append(pinyin, string(byte(theIdx-pyTableLen+97))) continue } pinyin = append(pinyin, pyTable[theIdx]) } // 读取一个或多个词 for i := 1; i \u003c= repeat; i++ { // 词长 wordSize := ReadUint16(r) // 读取词 tmp = make([]byte, wordSize) r.Read(tmp) word, _ := util.Decode(tmp, \"UTF-16LE\") // 末尾的补充信息，作用未知 extSize := ReadUint16(r) ext := make([]byte, extSize) r.Read(ext) ret = append(ret, Entry{word, pinyin, 1}) } } if r.Len() \u003c 16 { return ret } // 黑名单 r.Seek(12, 1) blackLen := ReadUint16(r) var black_list bytes.Buffer for i := 0; i \u003c blackLen; i++ { wordLen := ReadUint16(r) tmp = make([]byte, wordLen*2) r.Read(tmp) word, _ := util.Decode(tmp, \"UTF-16LE\") black_list.WriteString(word) black_list.WriteByte('\\n') } // os.WriteFile(\"black_list.txt\", black_list.Bytes(), 0666) return ret } 参考资料： 深蓝词库转换 将搜狗词库(scel)转为 Python 可读的文本 ","date":"2022-05-24","objectID":"/2022/05/02-sogou-scel/:1:3","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（二）搜狗拼音细胞词库.scel(.qcel)","uri":"/2022/05/02-sogou-scel/#黑名单"},{"categories":["输入法"],"content":".def 是百度手机输入法-更多设置-自定义输入方案所使用的格式。 ","date":"2022-05-24","objectID":"/2022/05/01-baidu-def/:0:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（一）百度自定义方案.def","uri":"/2022/05/01-baidu-def/#"},{"categories":["输入法"],"content":" 解析码表偏移量 0x6D # 占用字节数 描述 a 1 编码长度（红色框） b 1 词长 * 2 + 2 a 编码（黄色框），可以是纯编码，也可以是 编码=位置 b-2 词（绿色框），utf16-le 编码 6 6 个空字节代表词条结束 代码实现： go r.Seek(0x6D, 0) // 从 0x6D 开始读 for r.Len() \u003e 4 { codeLen, _ := r.ReadByte() // 编码长度 wordSize, _ := r.ReadByte() // 词长*2 + 2 // 读编码 tmp = make([]byte, int(codeLen)) r.Read(tmp) // 编码切片 code := string(tmp) spl := strings.Split(code, \"=\") // 直接删掉 = 号后的 code = spl[0] // 读词 tmp = make([]byte, int(wordSize)-2) // -2 后就是字节长度，没有考虑4字节的情况 r.Read(tmp) word, _ := util.Decode(tmp, \"UTF-16LE\") // def = append(def, defEntry{word, code, order}) ret = append(ret, Entry{word, code, 1}) r.Seek(6, 1) // 6个00，1是相对当前位置 } ","date":"2022-05-24","objectID":"/2022/05/01-baidu-def/:1:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（一）百度自定义方案.def","uri":"/2022/05/01-baidu-def/#解析"},{"categories":["输入法"],"content":" 生成码表部分和解析一样的，没什么好说的。 主要考虑前 0x6C(109) 个字节。 第一个字节意义不明，可能是最大码长（一般是 0，有的码表里是 4） 后面每 4 字节一组，共 27 组。 表示以 26 个首字母开头词条的字节长度累加（不包括前 2 个表示长度的字节，包括后 6 个 0） 计算时，统计每个首字母的长度累计，写入时再次累加。 代码实现： go func (BaiduDef) Gen(table Table) []byte { jdt := ToJdTable(table) var buf bytes.Buffer // 首字母词条字节数统计 lengthMap := make(map[byte]int) buf.Write(make([]byte, 0x6D)) for _, v := range jdt { code := v.Code for i, word := range v.Words { if i != 0 { // 不在首选的写入位置信息，好像没什么用？ code = v.Code + \"=\" + strconv.Itoa(i+1) } sliWord, _ := util.Encode([]byte(word), \"UTF-16LE\") // 转为utf-16le buf.WriteByte(byte(len(code))) // 写编码长度 buf.WriteByte(byte(len(sliWord) + 2)) // 写词字节长+2 buf.WriteString(code) // 写编码 buf.Write(sliWord) // 写词 buf.Write([]byte{0, 0, 0, 0, 0, 0}) // 写6个0 // 编码长度 + 词字节长 + 6，不包括长度本身占的2个字节 lengthMap[code[0]] += len(code) + len(sliWord) + 2 + 6 } } // 文件头 byteList := make([]byte, 0, 0x6D) byteList = append(byteList, 0) // 第一个字节可能是最大码长？ // 长度累加 var currNum int for i := 0; i \u003c= 26; i++ { currNum += lengthMap[byte(i+0x60)] currBytes := make([]byte, 4) binary.LittleEndian.PutUint32(currBytes, uint32(currNum)) byteList = append(byteList, currBytes...) } // 替换文件头 ret := buf.Bytes() copy(ret, byteList) return ret } 参考资料： DictTool 词库处理工具 ","date":"2022-05-24","objectID":"/2022/05/01-baidu-def/:2:0","series":["lexicon"],"tags":["输入法","词库","二进制"],"title":"输入法词库解析（一）百度自定义方案.def","uri":"/2022/05/01-baidu-def/#生成"},{"categories":null,"content":" 关于我 爱一定存在与世上，一定存在 无从寻觅的是爱的表现，是它的表达方式 关键词：00 后，重庆大学数学系，编程，输入法，游戏，音乐，追番，up 主。 输入法：星辰双拼，星辰星笔，小可两笔，倾心两笔。 音乐：流行，民谣，古风，轻音乐，古典，电音，日语，acg。 游戏：只玩 CF ，主玩跳跳乐模式，有在 b 站发视频。 语言：普通话，重庆话，英语 4 级。 编程：python，golang。 ","date":"2021-08-16","objectID":"/about/:1:0","series":null,"tags":null,"title":"更多","uri":"/about/#关于我"},{"categories":null,"content":" 友链 感谢 @芝士部落格 提供了友链页面模板~ 在友链形成的网络中漫游，是一件很有意思的事情。 以前的人们通过信笺交流，而我们通过友链串联起一个「世界」。希望你我都能在这个「世界」中有所收获 注： 下方友链次序每次刷新页面随机排列。 ","date":"2021-08-16","objectID":"/about/:2:0","series":null,"tags":null,"title":"更多","uri":"/about/#友链"},{"categories":null,"content":" 交换友链如果你觉得我的博客有些意思，而且也有自己的独立博客，欢迎与我交换友链~ 可在评论区提交友链申请，格式如下： 站点名称：nopdan's blog 作者: @nopdan 站点地址：https://nopdan.com/ 个人形象：https://nopdan.com/avatar.webp 站点描述：悟已往之不谏，知来者之可追。 ","date":"2021-08-16","objectID":"/about/:3:0","series":null,"tags":null,"title":"更多","uri":"/about/#交换友链"},{"categories":["笔记"],"content":"ssh-keygen 主要用于为 ssh(远程登录程序) 生成、管理和转换验证密钥。ssh-keygen 可以创建供 SSH 协议版本 1 使用的 RSA 密钥，以及供 SSH 协议版本 2 使用的 RSA 或 DSA 密钥。生成的密钥类型使用 -t 选项指定。 ssh-keygen 它支持 RSA 和 DSA 两种认证密钥，下面是的一些注意参数（可以使用 ssh-keygen /? 看看参数信息）： -b bits 指定要创建的密钥的位数。最小位数为 512 位。通常，2048 位足以满足安全需要。密钥大小超过该值并不会提高安全性，反而会降低速度。缺省值为 2048 位。 -B 显示指定的私钥或公钥文件的 bubblebabble 摘要。 -c 请求更改私钥和公钥文件中的注释。该程序会提示您提供包含私钥的文件、口令短语（如果密钥具有一个口令短语）以及新的注释。 此选项仅适用于 rsa1 (SSHv1) 密钥。 -C comment 提供新注释。 -e 此选项读取 OpenSSH 私钥或公钥文件并将密钥以 “SECSH” 公钥文件格式输出到 stdout。此选项允许导出密钥供其他一些 SSH 实现使用。 -f 指定密钥文件的文件名。 -F 在 known_hosts 文件中搜索指定的 hostname，列出找到的任何匹配项。此选项可用于查找散列格式的主机名或地址，还可以与 -H 选项一起使用，以散列格式输出找到的密钥。 -H 对 known_hosts 文件执行散列计算。此选项使用散列形式替换指定文件内的所有主机名和地址。原始内容将移动到后缀为 .old 的文件中。这些散列值通常由 ssh 和 sshd 使用，即使文件内容被公开，这些散列值也并不会透露可识别的信息。此选项不会修改现有的散列主机名，因此可以放心地用于同时包含散列名称和非散列名称的文件。 -i 此选项以 SSH2 兼容格式读取未加密的私钥（或公钥）文件并将 OpenSSH 兼容的私钥（或公钥）输出到 stdout。ssh-keygen 还可读取 “SECSH” 公钥文件格式。此选项允许从其他一些 SSH 实现中导入密钥。 -l 显示指定的私钥或公钥文件的指纹。 -N new_passphrase 提供新口令短语。 -p 请求更改私钥文件的口令短语，而不创建新私钥。该程序会提示您提供包含私钥的文件、旧口令短语，并两次提示您输入新口令短语。 -P passphrase 提供（旧）口令短语。 -q 退出 ssh-keygen。 -t type 指定用于生成密钥的算法，其中 type 是 rsa、dsa 和 rsa1 中的一种。rsa1 类型仅用于 SSHv1 协议。 -R hostname 从 known_hosts 文件中删除属于 hostname 的所有密钥。此选项可用于删除散列主机。请参见 -H。 -x 已过时。已被 -e 选项取代。 -X 已过时。已被 -i 选项取代。 -y 此选项读取 OpenSSH 私钥格式文件并将 OpenSSH 公钥输出到 stdout。 ","date":"2020-04-25","objectID":"/2020/04/ssh-keygen/:0:0","series":null,"tags":["ssh"],"title":"使用 ssh-keygen 生成密钥","uri":"/2020/04/ssh-keygen/#"},{"categories":["笔记"],"content":"在设置\"哪些图标显示在任务栏上\"后，当我们卸装软件、更改软件目录就可能导致缓存不刷新，只需如下几步就可以清除你的任务栏图标缓存。 ","date":"2020-03-18","objectID":"/2020/03/taskbar-cache/:0:0","series":null,"tags":["windows"],"title":"清除\"哪些图标显示在任务栏上\"缓存","uri":"/2020/03/taskbar-cache/#"},{"categories":["笔记"],"content":" 删注册表项快捷键 win+r, 输入 regedit 打开注册表，找到 HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\TrayNotify 找到以下两个键值IconStreams和PastIconsStream，将它们的值删除。 ","date":"2020-03-18","objectID":"/2020/03/taskbar-cache/:1:0","series":null,"tags":["windows"],"title":"清除\"哪些图标显示在任务栏上\"缓存","uri":"/2020/03/taskbar-cache/#删注册表项"},{"categories":["笔记"],"content":" 重启资源管理器快捷键 ctrl+shift+esc 打开任务管理器，找到 windows 资源管理器，右击重启。 ","date":"2020-03-18","objectID":"/2020/03/taskbar-cache/:2:0","series":null,"tags":["windows"],"title":"清除\"哪些图标显示在任务栏上\"缓存","uri":"/2020/03/taskbar-cache/#重启资源管理器"},{"categories":["笔记"],"content":"Scoop 和 chocolatey 一样，是 windows 上的包管理软件。 它不需要管理员权限就能安装软件到用户目录，用户目录和全局目录都可以自定义。 下面是我的安装目录 ","date":"2019-11-27","objectID":"/2019/11/scoop/:0:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#"},{"categories":["笔记"],"content":" 安装 Scoop进入官网可以看到 Scoop 的安装非常简单 需要 powershell 5 和 .NET Framework 4.5 及以上版本 输入以下命令 powershell Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh') # 或者 短命令 iwr -useb get.scoop.sh | iex # (如果上述命令报错，先运行下面这行命令) Set-ExecutionPolicy RemoteSigned -scope CurrentUser 运行 scoop help 检查是否安装成功 text PS C:\\Users\\Elio\u003e scoop help Usage: scoop \u003ccommand\u003e [\u003cargs\u003e] Some useful commands are: alias Manage scoop aliases bucket Manage Scoop buckets cache Show or clear the download cache checkup Check for potential problems cleanup Cleanup apps by removing old versions config Get or set configuration values create Create a custom app manifest depends List dependencies for an app export Exports (an importable) list of installed apps help Show help for a command hold Hold an app to disable updates home Opens the app homepage info Display information about an app install Install apps list List installed apps prefix Returns the path to the specified app reset Reset an app to resolve conflicts search Search available apps status Show status and check for new app versions unhold Unhold an app to enable updates uninstall Uninstall an app update Update apps, or Scoop itself virustotal Look for app's hash on virustotal.com which Locate a shim/executable (similar to 'which' on Linux) Type 'scoop help \u003ccommand\u003e' to get help for a specific command. ","date":"2019-11-27","objectID":"/2019/11/scoop/:1:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#安装-scoop"},{"categories":["笔记"],"content":" 安装目录Scoop 软件默认安装到 C:\\Users\\\u003c用户名\u003e\\scoop\\ 下 全局默认安装到 C:\\ProgramData\\scoop\\ 下，通过 shim 软链接应用 你可以添加 SCOOP 用户环境变量更改用户安装目录 添加 SCOOP_GLOBAL 系统变量更改全局安装目录 ","date":"2019-11-27","objectID":"/2019/11/scoop/:2:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#安装目录"},{"categories":["笔记"],"content":" 安装软件使用 scoop install \u003cPackageName\u003e 安装软件 在 PackageName 后加 @version 安装指定版本软件 添加 -g 属性安装到全局目录 ","date":"2019-11-27","objectID":"/2019/11/scoop/:3:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#安装软件"},{"categories":["笔记"],"content":" 卸装软件将上面的 install 改为 uninstall ","date":"2019-11-27","objectID":"/2019/11/scoop/:4:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#卸装软件"},{"categories":["笔记"],"content":" 更新软件将上面的 install 改为 update 可以使用 scoop update * 更新全部软件 ","date":"2019-11-27","objectID":"/2019/11/scoop/:5:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#更新软件"},{"categories":["笔记"],"content":" 查看软件是否最新scoop status ","date":"2019-11-27","objectID":"/2019/11/scoop/:6:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#查看软件是否最新"},{"categories":["笔记"],"content":" 重置软件，可切换软件版本scoop reset \u003cPackageName\u003e 如同时安装 zulu8 和 zulu11,切换 jdk 环境为 zulu8 scoop reset zulu8 ","date":"2019-11-27","objectID":"/2019/11/scoop/:7:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#重置软件可切换软件版本"},{"categories":["笔记"],"content":" 清除软件旧版本scoop cleanup \u003cPackageName\u003e 清除所有软件旧版本 scoop cleanup * ","date":"2019-11-27","objectID":"/2019/11/scoop/:8:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#清除软件旧版本"},{"categories":["笔记"],"content":" 搜索包scoop search \u003cPackageName\u003e ","date":"2019-11-27","objectID":"/2019/11/scoop/:9:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#搜索包"},{"categories":["笔记"],"content":" 列出已安装包scoop list ","date":"2019-11-27","objectID":"/2019/11/scoop/:10:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#列出已安装包"},{"categories":["笔记"],"content":" 添加 bukectScoop 的软件数量不多，但可以通过 bukect 添加软件源 输入 scoop bucket known 列出官方认证的 bucket text PS C:\\Users\\Elio\u003e scoop bucket known main extras versions nightlies nirsoft php nerd-fonts nonportable java games jetbrains 输入 scoop add java 就可以添加 java 源 也可以输入 scoop bucket add \u003cname\u003e [\u003c仓库地址\u003e] 添加其他源 ","date":"2019-11-27","objectID":"/2019/11/scoop/:11:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#添加-bukect"},{"categories":["笔记"],"content":" 使用代理scoop config proxy 127.0.0.1:1080 ","date":"2019-11-27","objectID":"/2019/11/scoop/:12:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#使用代理"},{"categories":["笔记"],"content":" 配置文件路径C:\\Users\\\u003c用户名\u003e\\.config\\scoop\\ ","date":"2019-11-27","objectID":"/2019/11/scoop/:13:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#配置文件路径"},{"categories":["笔记"],"content":" 缺点 Scoop 大量使用 github 作为下载来源，建议使用代理 国内软件，gui 软件收录较少 安装失败需要卸装后再次安装 ","date":"2019-11-27","objectID":"/2019/11/scoop/:14:0","series":null,"tags":["windows","工具"],"title":"Scoop | windows上的包管理神器","uri":"/2019/11/scoop/#缺点"},{"categories":["笔记"],"content":"Win 10 的 UWP 应用 (应用商店下载的 APP)，默认是不走代理的 (沙盒的网络隔离特性：禁止 APP 访问 localhost)，也就无法在中国使用像 Facebook 一样无法访问或者直接链接特别慢的 APP。 ","date":"2019-11-21","objectID":"/2019/11/uwp-proxy/:0:0","series":null,"tags":["windows"],"title":"为uwp应用设置系统代理","uri":"/2019/11/uwp-proxy/#"},{"categories":["笔记"],"content":" 一、CheckNetIsolation","date":"2019-11-21","objectID":"/2019/11/uwp-proxy/:1:0","series":null,"tags":["windows"],"title":"为uwp应用设置系统代理","uri":"/2019/11/uwp-proxy/#一checknetisolation"},{"categories":["笔记"],"content":" 为单个 UWP 应用设置代理 指定 app 名称 在资源管理器地址栏输入： text C:\\Users\\%username%\\AppData\\Local\\Packages 命令行输入： powershell CheckNetIsolation.exe LoopbackExempt -a -n=\"APP名称\" # 例 CheckNetIsolation.exe LoopbackExempt -a -n=\"903DB504.QQWP_a99ra4d2cbcxa\" 如需取消只需将 -a 换成 -d 指定 SID 找 SID，在地址栏输入： text HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Mappings 命令行输入： powershell CheckNetIsolation.exe LoopbackExempt -a -p=APP的SID # 例 CheckNetIsolation.exe loopbackexempt -a -p=S-1-15-2-3603386487-2480558841-1671909046-581189492-76553544-2527268699-3538496040 如需取消只需将 -a 换成 -d ","date":"2019-11-21","objectID":"/2019/11/uwp-proxy/:1:1","series":null,"tags":["windows"],"title":"为uwp应用设置系统代理","uri":"/2019/11/uwp-proxy/#为单个-uwp-应用设置代理"},{"categories":["笔记"],"content":" 为单个 UWP 应用设置代理 指定 app 名称 在资源管理器地址栏输入： text C:\\Users\\%username%\\AppData\\Local\\Packages 命令行输入： powershell CheckNetIsolation.exe LoopbackExempt -a -n=\"APP名称\" # 例 CheckNetIsolation.exe LoopbackExempt -a -n=\"903DB504.QQWP_a99ra4d2cbcxa\" 如需取消只需将 -a 换成 -d 指定 SID 找 SID，在地址栏输入： text HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Mappings 命令行输入： powershell CheckNetIsolation.exe LoopbackExempt -a -p=APP的SID # 例 CheckNetIsolation.exe loopbackexempt -a -p=S-1-15-2-3603386487-2480558841-1671909046-581189492-76553544-2527268699-3538496040 如需取消只需将 -a 换成 -d ","date":"2019-11-21","objectID":"/2019/11/uwp-proxy/:1:1","series":null,"tags":["windows"],"title":"为uwp应用设置系统代理","uri":"/2019/11/uwp-proxy/#指定-app-名称"},{"categories":["笔记"],"content":" 为单个 UWP 应用设置代理 指定 app 名称 在资源管理器地址栏输入： text C:\\Users\\%username%\\AppData\\Local\\Packages 命令行输入： powershell CheckNetIsolation.exe LoopbackExempt -a -n=\"APP名称\" # 例 CheckNetIsolation.exe LoopbackExempt -a -n=\"903DB504.QQWP_a99ra4d2cbcxa\" 如需取消只需将 -a 换成 -d 指定 SID 找 SID，在地址栏输入： text HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Mappings 命令行输入： powershell CheckNetIsolation.exe LoopbackExempt -a -p=APP的SID # 例 CheckNetIsolation.exe loopbackexempt -a -p=S-1-15-2-3603386487-2480558841-1671909046-581189492-76553544-2527268699-3538496040 如需取消只需将 -a 换成 -d ","date":"2019-11-21","objectID":"/2019/11/uwp-proxy/:1:1","series":null,"tags":["windows"],"title":"为uwp应用设置系统代理","uri":"/2019/11/uwp-proxy/#指定-sid"},{"categories":["笔记"],"content":" 为全部 UWP 应用设置代理powershell 命令(读取注册表中的所有 SID)： powershell foreach ( $Obj in Get-ChildItem \"HKCU:\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Mappings\\\" -name ) { CheckNetIsolation.exe LoopbackExempt -a -n=$Oj } CMD 命令： powershell FOR /F \"tokens=11 delims=\\\" %p IN ('REG QUERY \"HKCU\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Mappings\"') DO CheckNetIsolation.exe LoopbackExempt -a -p=%p ","date":"2019-11-21","objectID":"/2019/11/uwp-proxy/:1:2","series":null,"tags":["windows"],"title":"为uwp应用设置系统代理","uri":"/2019/11/uwp-proxy/#为全部-uwp-应用设置代理"},{"categories":["笔记"],"content":" 二、使用其他软件Fiddler: https://www.telerik.com/fiddler ","date":"2019-11-21","objectID":"/2019/11/uwp-proxy/:2:0","series":null,"tags":["windows"],"title":"为uwp应用设置系统代理","uri":"/2019/11/uwp-proxy/#二使用其他软件"},{"categories":["笔记"],"content":" 三、python 脚本https://yuan.ga/enable-win10-uwp-use-system-proxy/ ","date":"2019-11-21","objectID":"/2019/11/uwp-proxy/:3:0","series":null,"tags":["windows"],"title":"为uwp应用设置系统代理","uri":"/2019/11/uwp-proxy/#三python-脚本"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/index.en/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/index.en/#"}]